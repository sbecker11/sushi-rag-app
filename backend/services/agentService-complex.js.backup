import { ChatOpenAI } from '@langchain/openai';
import { initializeAgentExecutorWithOptions } from 'langchain/agents';
import { ChatPromptTemplate, MessagesPlaceholder } from '@langchain/core/prompts';
import { DynamicStructuredTool } from 'langchain/tools';
import vectorStore from './vectorStore.js';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load .env from project root
dotenv.config({ path: join(__dirname, '..', '..', '.env') });

class AgentService {
  constructor() {
    this.llm = null;
    this.tools = [];
    this.agent = null;
    this.executor = null;
    this.initialized = false;
  }

  async initialize() {
    if (this.initialized) {
      return;
    }

    try {
      // Check if OpenAI API key is configured
      if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === 'your_openai_api_key_here') {
        console.log('‚ö†Ô∏è  OpenAI API key not configured - Agent disabled');
        return;
      }

      // Initialize LLM
      this.llm = new ChatOpenAI({
        modelName: 'gpt-4',
        temperature: 0.7,
        openAIApiKey: process.env.OPENAI_API_KEY
      });

      // Create tools
      this.tools = this.createTools();

      // Create executor using the simple initialization (works with langchain 1.x)
      this.executor = await initializeAgentExecutorWithOptions(
        this.tools,
        this.llm,
        {
          agentType: "openai-functions",
          verbose: process.env.ENABLE_PERFORMANCE_LOGGING === 'true',
          maxIterations: 5,
          agentArgs: {
            prefix: `You are a helpful assistant for a sushi restaurant. You help customers find menu items, answer questions about the menu, and make recommendations.

Be friendly, concise, and helpful. Use the available tools to answer questions accurately.

If you can't find what the user is looking for, politely suggest alternatives.`
          }
        }
      );

      this.initialized = true;
      console.log('‚úÖ Agent service initialized with', this.tools.length, 'tools');
    } catch (error) {
      console.error('‚ùå Agent service initialization failed:', error.message);
      this.initialized = false;
    }
  }

  createTools() {
    return [
      // Tool 1: Semantic Search
      new DynamicStructuredTool({
        name: 'search_menu',
        description: 'Search for menu items semantically using natural language. Use this when users ask for types of food, flavors, dietary preferences, or general menu exploration. Input should be a search query like "spicy rolls", "vegetarian options", or "appetizers".',
        func: async (query) => {
          try {
            console.log(`üîß Tool: search_menu("${query}")`);
            
            if (!vectorStore.isInitialized()) {
              return JSON.stringify({ error: 'Menu database not available' });
            }

            const results = await vectorStore.semanticSearch(query, 5);
            
            if (results.length === 0) {
              return JSON.stringify({ message: 'No items found matching your criteria' });
            }

            return JSON.stringify(results.map(r => ({
              id: r.id,
              name: r.name,
              description: r.description,
              price: r.price,
              category: r.category,
              dietary: r.dietary,
              spiceLevel: r.spiceLevel
            })));
          } catch (error) {
            console.error('Error in search_menu tool:', error);
            return JSON.stringify({ error: 'Search failed' });
          }
        }
      }),

      // Tool 2: Filter by Price
      new DynamicStructuredTool({
        name: 'filter_by_price',
        description: 'Filter menu items by price range. Use this when users ask about prices like "under $10", "between $15 and $20", or "affordable options". Input should be a JSON string with min and/or max price, e.g., {"max": 10} or {"min": 15, "max": 20}.',
        func: async (priceRangeJson) => {
          try {
            console.log(`üîß Tool: filter_by_price(${priceRangeJson})`);
            
            if (!vectorStore.isInitialized()) {
              return JSON.stringify({ error: 'Menu database not available' });
            }

            const priceRange = JSON.parse(priceRangeJson);
            const allItems = await vectorStore.semanticSearch('menu items', 20);
            
            let filtered = allItems;
            
            if (priceRange.min !== undefined) {
              filtered = filtered.filter(item => item.price >= priceRange.min);
            }
            
            if (priceRange.max !== undefined) {
              filtered = filtered.filter(item => item.price <= priceRange.max);
            }

            if (filtered.length === 0) {
              return JSON.stringify({ message: 'No items found in that price range' });
            }

            return JSON.stringify(filtered.map(r => ({
              id: r.id,
              name: r.name,
              description: r.description,
              price: r.price
            })));
          } catch (error) {
            console.error('Error in filter_by_price tool:', error);
            return JSON.stringify({ error: 'Price filtering failed' });
          }
        }
      }),

      // Tool 3: Get Item Details
      new DynamicStructuredTool({
        name: 'get_item_details',
        description: 'Get detailed information about a specific menu item by name. Use this when users ask about ingredients, preparation, or specific details about a dish. Input should be the item name.',
        func: async (itemName) => {
          try {
            console.log(`üîß Tool: get_item_details("${itemName}")`);
            
            if (!vectorStore.isInitialized()) {
              return JSON.stringify({ error: 'Menu database not available' });
            }

            const results = await vectorStore.semanticSearch(itemName, 1);
            
            if (results.length === 0) {
              return JSON.stringify({ message: 'Item not found' });
            }

            const item = results[0];
            return JSON.stringify({
              id: item.id,
              name: item.name,
              description: item.description,
              price: item.price,
              ingredients: item.ingredients,
              category: item.category,
              dietary: item.dietary,
              spiceLevel: item.spiceLevel,
              image: item.image
            });
          } catch (error) {
            console.error('Error in get_item_details tool:', error);
            return JSON.stringify({ error: 'Failed to get item details' });
          }
        }
      })
    ];
  }

  async chat(message, chatHistory = []) {
    if (!this.initialized || !this.executor) {
      return {
        response: 'Sorry, the AI assistant is not available at the moment.',
        toolsUsed: []
      };
    }

    try {
      const startTime = Date.now();
      console.log(`ü§ñ Agent Chat: "${message}"`);

      const result = await this.executor.invoke({
        input: message,
        chat_history: chatHistory
      });

      if (process.env.ENABLE_PERFORMANCE_LOGGING === 'true') {
        console.log(`‚è±Ô∏è  Agent Total Time: ${Date.now() - startTime}ms`);
      }

      // Extract tool usage information
      const toolsUsed = [];
      if (result.intermediateSteps) {
        for (const step of result.intermediateSteps) {
          if (step.action) {
            toolsUsed.push({
              tool: step.action.tool,
              input: step.action.toolInput
            });
          }
        }
      }

      console.log(`‚úÖ Agent response generated (used ${toolsUsed.length} tools)`);

      return {
        response: result.output,
        toolsUsed
      };
    } catch (error) {
      console.error('‚ùå Agent error:', error.message);
      return {
        response: 'Sorry, I encountered an error while processing your request. Please try again.',
        toolsUsed: []
      };
    }
  }

  isInitialized() {
    return this.initialized;
  }
}

// Create singleton instance
const agentService = new AgentService();

export default agentService;

